use std::env;
use std::fs;
use std::process::Command;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let out_dir = env::var("OUT_DIR")?;
    let shader_dir = "src/gpu_transformer/shaders";

    // Create the output file for embedded shaders
    let output_file = format!("{out_dir}/embedded_shaders.rs");

    let shaders = [
        "linear.comp",
        "gelu.comp",
        "layernorm_forward.comp",
        "layernorm_backward.comp",
        "layernorm_adam_update.comp",
        "linear_batched_forward.comp",
        "linear_batched_backward.comp",
        "feedforward_backward.comp",
        "attention_scores.comp",
        "attention_scores_backward.comp",
        "attention_softmax.comp",
        "attention_softmax_backward.comp",
        "attention_apply.comp",
        "attention_apply_backward.comp",
        "adam_update.comp",
    ];

    for shader in &shaders {
        println!("cargo:rerun-if-changed={shader_dir}/{shader}");
    }

    let mut embedded_shaders = String::new();
    embedded_shaders.push_str("// Auto-generated embedded shaders\n");
    embedded_shaders.push_str("// This file is generated by build.rs\n\n");

    let mut compiled_shaders = Vec::new();
    let mut glslang_available = true;

    // Check if glslangValidator is available
    if Command::new("glslangValidator")
        .arg("--version")
        .output()
        .is_err()
    {
        println!("Warning: glslangValidator not found. Shader compilation will be skipped.");
        glslang_available = false;
    }

    // Shader constants
    for shader in &shaders {
        if !glslang_available {
            println!("Skipping {shader} compilation (glslangValidator not available)");
            continue;
        }

        let input_shader = format!("{shader_dir}/{shader}");
        let output_spv = format!("{out_dir}/{shader}.spv");
        println!("Compiling {shader}...");

        // Compile shader to SPIR-V file
        let status = Command::new("glslangValidator")
            .args(["-V", &input_shader, "-o", &output_spv])
            .status();
        match status {
            Ok(s) if s.success() => {
                println!("âœ“ Successfully compiled {shader} to SPIR-V");
                // Read the SPIR-V file as bytes
                let bytes = fs::read(&output_spv)?;
                if bytes.len() % 4 != 0 {
                    return Err(format!(
                        "Invalid SPIR-V file for {shader}: size is not a multiple of 4"
                    )
                    .into());
                }
                let shader_name = shader
                    .replace(".comp", "_shader")
                    .replace(".", "_")
                    .to_uppercase();
                embedded_shaders.push_str(&format!("pub const {shader_name}: &[u32] = &[\n"));
                let words: Vec<u32> = bytes
                    .chunks_exact(4)
                    .map(|chunk| u32::from_le_bytes([chunk[0], chunk[1], chunk[2], chunk[3]]))
                    .collect();
                for (i, word) in words.iter().enumerate() {
                    if i % 4 == 0 {
                        embedded_shaders.push_str("    ");
                    }
                    embedded_shaders.push_str(&format!("0x{word:08x}, "));
                    if i % 4 == 3 || i == words.len() - 1 {
                        embedded_shaders.push('\n');
                    }
                }
                embedded_shaders.push_str("];\n\n");
                compiled_shaders.push(shader.to_string());
            }
            Ok(_) => {
                return Err(format!("Failed to compile {shader} shader").into());
            }
            Err(e) => {
                return Err(format!("Failed to run glslangValidator for {shader}: {e}").into());
            }
        }
    }

    // Add AVAILABLE_SHADERS and get_shader function
    embedded_shaders.push_str("pub const AVAILABLE_SHADERS: &[&str] = &[\n");
    for shader in &compiled_shaders {
        embedded_shaders.push_str(&format!("    \"{shader}\",\n"));
    }
    embedded_shaders.push_str(
        "];
\n",
    );

    embedded_shaders.push_str("/// Get a shader by name\n");
    if compiled_shaders.is_empty() {
        embedded_shaders.push_str(
            "pub fn get_shader(_shader_name: &str) -> Option<&'static [u32]> {\n    None\n}\n",
        );
    } else {
        embedded_shaders.push_str("pub fn get_shader(shader_name: &str) -> Option<&'static [u32]> {\n    match shader_name {\n");
        for shader in &compiled_shaders {
            let shader_name = shader
                .replace(".comp", "_shader")
                .replace(".", "_")
                .to_uppercase();
            embedded_shaders.push_str(&format!("        \"{shader}\" => Some({shader_name}),\n"));
        }
        embedded_shaders.push_str("        _ => None,\n    }\n}\n");
    }

    // Write the embedded shaders to the output file
    fs::write(&output_file, embedded_shaders)?;
    println!("cargo:rustc-env=EMBEDDED_SHADERS_FILE={output_file}");

    Ok(())
}
